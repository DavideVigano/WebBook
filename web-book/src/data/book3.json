{
    "title": "Defensive Security",
    "preview": "La Sicurezza Difensiva, o Defensive Security, è un approccio alla protezione delle informazioni e dei sistemi informatici che si concentra sulla prevenzione, la rilevazione e la mitigazione degli attacchi informatici. A differenza della Sicurezza Offensiva, che si concentra sull'attacco e la penetrazione dei sistemi, la Sicurezza Difensiva è orientata a difendere e proteggere i sistemi da potenziali minacce.",
    "copertina": "https://focus.namirial.it/wp-content/uploads/sites/2/2022/10/information-security-640x427.jpg",
    "tag": [
        "Istruzione",
        "Sicurezza",
        "Informatica"
    ],
    "capitoli": [
        {
            "title": "Defensive security",
            "sections": [
                {
                    "subtitle": "Controllo degli Accessi",
                    "content": "<p>Il controllo degli accessi è un pilastro fondamentale per la sicurezza.</p>\n<blockquote>\n<p>sono dei meccanismi che prevengono l'uso non autorizzato delle risorse e chi può accedere, utilizzi la risorsa solo per quello che è stato autorizzato</p>\n</blockquote>\n<p>l'accesso controllato ad una risorsa viene fatta in 3 momenti, vengono chiamate <strong>regole Auree</strong> e sono:</p>\n<ul>\n<li><strong>Autenticazione</strong>, chi sta accedento</li>\n<li><strong>Autorizzazione</strong> assegnare dei diritti o dei privilegi ad utenti che si sono autenticati precedentemente.</li>\n<li><strong>Auditing</strong> è la parte di Accountability, si tiene traccia di chi fa cosa (in un registro → log), sostanzailmente prende le misure per sapere chi ha fatto cosa, un po' come delle telecamere, se qualcuno riesce a fare qualcosa che non dovrebbe poter fare voglio sapere chi è stato, parto dal pressupposto che le mie protezioni non sono infallibili e quindi se superate voglio sapere chi è stato, questo è possibile grazie ai file di log.</li>\n</ul>\n<p><strong>Enforcement Mechanism</strong>, sono dei meccanismi che rinforzano i controlli.</p>\n<p>l'obbiettivo di chi attacca è quello di superare questi meccanismi di protezione.<br>\nIl controllo degli accessi individua 3 categorie su cui operare:</p>\n<ul>\n<li>\n<p><strong>soggetti</strong>, sono <strong>entità attive</strong> che possono usare le risorse (in un calcolatore sono i processi).</p>\n<p><em>nb utente opera su un proesso il quale a sua volta opera su una risorsa → utente soggetto secondario, processo utente primario.</em></p>\n</li>\n<li>\n<p><strong>oggetti</strong>, sono le risorse che subiscono le azioni, <strong>attività passive</strong> (un processo può essere un oggetto, può essere modificato).</p>\n<p><em>nb: un processo a volte può essere sia soggetto che oggetto, talvolta anche entrambi contemporaneamente</em></p>\n</li>\n<li>\n<p><strong>Diritti</strong> o <strong>Access Operation</strong>, attività che possono essere svolte su un certo tipo di dati.</p>\n</li>\n</ul>\n<p>I processi possono essere sia oggetti che soggetti.<br>\nRead, Write e Execute sono attività che possono essere svolte su un oggetto.</p>\n<p>![The model](/Users/davidevigano/Documents/Sicurezza/SicurezzaFoto/The model.png)</p>\n<p>il controllo viene fatto dal Refereces monitor</p>\n<p>Referencens monitor controlla una policy, in base a questo decide se autorizzarlo o no</p>\n<p>contemporaneamente la richiesta viene memorizzata in un file di Log (qui fa auditing).</p>\n<p>tutta la sicurezza sta nel references monitor, è un oggetto particolarmente critico</p>\n<ul>\n<li>Complete mediation, ovvero media tutti i tentativi dei soggetti ad accedere agli oggetti</li>\n<li>Be tamper proof ,  a prova di manomissione</li>\n<li>sufficentemente piccolo (così da poter verificare la correttezza)</li>\n</ul>\n<p>ad un utente viene assegnata un identità logica (ID) a seguito di un autenticazione viene assegnata una identità fisica.</p>\n<p>una volta identificato l'utente entra nel sistema di Autorizzazione (controllo degli accessi)</p>"
                },
                {
                    "subtitle": "ACL",
                    "content": "<p>Un elenco di controllo di accesso (ACL) è un elenco di regole che specifica a quali utenti o sistemi viene concesso o negato l'accesso a un particolare oggetto o risorsa di sistema.</p>\n<p>cosa è un accesso autorizzato e uno non ?</p>\n<p>questo viene spiegato tramite le security policy, le quali ci dicono cosa intendiamo per utenti autorizzati e non</p>\n<p>dovremmo garintire a utenti autorizzati di accedere alle risorse e impedire di accedere a quelli non autorizzati</p>\n<p>le ACL le troviamo a ogni livello</p>\n<ul>\n<li>applicativo</li>\n<li>service</li>\n<li>SO</li>\n<li>hardware</li>\n<li>Kernel</li>\n</ul>\n<p>Quindi vengono definite delle autorizzazioni:</p>\n<ul>\n<li><strong>regole (o politiche)</strong> specifico chi e come</li>\n<li><strong>meccanismi</strong> strumenti per imporre le regole</li>\n</ul>\n<h3>Policy</h3>\n<p>le policy di sicurezza seguono 2 principi:</p>\n<ul>\n<li><strong>least privilage,</strong> ad ogni soggetto deve essre garantito il livello minimo di priveligi per eseguire le attività</li>\n<li><strong>Separention / segregation of duty</strong> , l'esecuzione di una serie di compiti viene svolta da persone diverse.<br>\n<em>ex amministratore della rete non ha senso che faccia l'Auditing della rete (c'è chi fa e chi controlla).</em></li>\n</ul>\n<p><strong>Politica di sicurezza</strong> indica quali sono le risorse da proteggere e indica chi può fare cose su queste risorse.</p>\n<p><em>noi la vediamo esclusivamente per le ACL</em></p>\n<h3>Politiche controlli degli accessi</h3>\n<p><img src=\"/Users/davidevigano/Documents/Sicurezza/SicurezzaFoto/ALC.png\" alt=\"ACL\"></p>\n<p>matrice, righe soggetti colonne oggetti</p>\n<p>chi scrive la matrice per il controllo degli accessi:</p>\n<ul>\n<li><strong>Disorintary Access Control (DAC)</strong>, matrice compilata per colonna dall'owner, le politiche d'accesso al file vengono scelte dal creatore del file.<br>\n<em>vedo appunti lezione 4 - UNIX</em></li>\n<li><strong>Mandatory Access Control (MAC)</strong> , matrice viene scritta da un ufficio preposto, basate su livelli.</li>\n<li><strong>Role Based Access Control (RBAC)</strong>, via di mezzo tra quelle sopra, le attività sono definite dal ruolo che ho all'interno dell'organizzazione.</li>\n</ul>\n<p>la Politica di controllo degli accessi è presente in tutti i livelli del sistema (<em>ex : liv hardware → MMU</em>)</p>"
                },
                {
                    "subtitle": "MAC mandatory access control",
                    "content": "<p>Il termine <strong>mandatory access control</strong> (<strong>MAC</strong>, in italiano: &quot;controllo d'accesso vincolato&quot;) indica un tipo di controllo d'accesso alle risorse del sistema attraverso il quale il SO vincola la capacità di un soggetto  di eseguire diverse operazioni su un oggetto o un obiettivo del sistema stesso.</p>\n<p>l'utente non può modifcare questa politica, hardware deve proteggere il sistema operativo.</p>\n<p>il SO è una risorsa, se non provvedessimo a difenderlo un utene potrebbe modificarlo, deve essere lo stesso per tutti, il SO operativo non ha un meccanismo per proteggersi, perché chi può modificare il SO potrebbe modificare questo meccanismo</p>\n<p>l'unico che può proteggerlo è un oggetto non accessibili agli utenti → l'hardware</p>\n<p>l'hardware controlla il primo pezzetto di references monitor</p>\n<p>l'hardware assegna ad ogni oggetto/soggetto una lable di privilegi (<strong>Ring)</strong> tot sono 4, 0 può fare tutto</p>\n<p>(in OS linux solo 0 e 3)</p>\n<p><img src=\"/Users/davidevigano/Documents/Sicurezza/SicurezzaFoto/675px-Priv_rings.png\" alt=\"Ring\"></p>\n<p>Il compilatore divide ogni processo in segmenti, gli <strong>oggetti</strong> e <strong>soggetti</strong> all'interno di archi intel sono i <strong>segmenti</strong>.</p>\n<h3>Segmentazione</h3>\n<p>La segmentazione è una tecnica di allocazione non contigua dei processi in memoria che differisce dalla paginazione perché i processi sono suddivisi in blocchi, detti segmenti, di differente dimensione. Analogamente a quanto succede alle pagine con la paginazione, un processo segmentato è allocato in memoria per segmenti non necessariamente adiacenti.</p>\n<p>Con la segmentazione un processo è suddiviso in blocchi secondo criteri logici che riflettono l’organizzazione del software. Per esempio un programma potrebbe essere composto da un certo numero di segmenti secondo la strutturazione dei moduli che lo compongono: un segmento per il programma principale, uno per ogni sottoprogramma, un altro ancora per un blocco di dati e così via. La segmentazione riflette quindi la visione che il programmatore ha del proprio programma.</p>\n<p><img src=\"/Users/davidevigano/Documents/Sicurezza/SicurezzaFoto/segmentazione.png\" alt=\"Segmentazione\"></p>\n<p>Con la segmentazione un processo è suddiviso in segmenti, ognuno dei quali possiede una precisa identità logica e funzionale e ha un proprio spazio di indirizzamento.</p>\n<p>Nello spazio di memoria segmentato i bit che compongono l’indirizzo di una cella di memoria sono scomposti in due parti:</p>\n<ul>\n<li>gli s bit più significativi identificano il numero di segmento;</li>\n<li>i rimanenti d bit meno significativi indicano la posizione della parola nel segmento.</li>\n</ul>\n<p><img src=\"/Users/davidevigano/Documents/Sicurezza/SicurezzaFoto/segment02.png\" alt=\"segmento\"></p>\n<h4>La tabella dei segmenti</h4>\n<p>Con la segmentazione un processo è allocato in memoria per segmenti. Per collocare un segmento in memoria il sistema operativo deve trovare un zona libera della memoria di dimensione uguale a quella del segmento. Le informazioni sul posizionamento dei segmenti di un processo in memoria sono inserite in una struttura dati analoga alla tabella delle pagine, detta tabella dei segmenti, che è usata dalla MMU per costruire l’indirizzo fisico di una cella di memoria. La segmentazione può essere usata con o senza la memoria virtuale. Nel caso di memoria virtuale segmentata, il formato di una riga della tabella dei segmenti è il seguente:</p>\n<p><img src=\"/Users/davidevigano/Documents/Sicurezza/SicurezzaFoto/segmento3.png\" alt=\"segmento3\"></p>\n<p>Ogni riga della tabella dei segmenti contiene, oltre ai bit di controllo e all’indirizzo di base del segmento, anche la sua dimensione. L’indirizzo di base e la dimensione del segmento identificano lo spazio di memoria fisica occupato dal segmento. La figura seguente mostra un esempio di elemento di tabella dei segmenti: il segmento 5 del processo è presente in memoria a partire dall’indirizzo 12000 sino alla locazione 18400.</p>\n<p><img src=\"/Users/davidevigano/Documents/Sicurezza/SicurezzaFoto/segmento4.png\" alt=\"segmento4\"></p>\n<p>Un processo, nel corso dell’esecuzione, referenzia la memoria con indirizzi virtuali secondo il formato sopra specificato. <strong>La MMU costruisce il mapping tra indirizzi virtuali e indirizzi fisici usando le informazioni contenute nella tabella dei segmenti</strong>. L’indirizzo di base della tabella dei segmenti è usato come registro base per la rilocazione dinamica del segmento, mentre la dimensione del segmento è usata per proteggere gli accessi alla memoria: un indirizzo virtuale che referenzia un certo segmento deve avere un offset minore o uguale alla dimensione del segmento stesso. Se invece l’offset è maggiore della dimensione del segmento, significa che il processo ha generato un indirizzo di una cella di memoria esterna al segmento. Per calcolare l’indirizzo corrispondente all’indirizzo virtuale 05002538, la MMU segue il seguente schema di funzionamento. In esso sono ipotizzati indirizzi virtuali con 2 cifre decimali per il segmento e 6 cifre decimali per la posizione nel segmento.</p>\n<p><img src=\"/Users/davidevigano/Documents/Sicurezza/SicurezzaFoto/segmento5.png\" alt=\"segmento5\"></p>\n<p>Il numero di segmento è usato per accedere alla corrispondente linea della tabella dei segmenti. Il bit di validità V vale 1 e quindi il segmento è in memoria. L’offset è minore della dimensione del segmento e l’indirizzo referenzia una posizione della memoria fisica, 14538, ottenuta sommando all’offset, 2538, l’indirizzo di base del segmento 5, 12000. Nella costruzione dell’indirizzo fisico ci sono due possibili situazioni anomale:</p>\n<ul>\n<li>un offset di valore maggiore della dimensione del segmento</li>\n<li>l’assenza del segmento in memoria.</li>\n</ul>\n<p>La MMU, rilevata la condizione di errore, la segnala con un’interruzione che provoca l’intervento del sistema operativo per portare il segmento mancante in memoria o per interrompere l’esecuzione del programma per violazione della memoria.</p>\n<p>Dal punto di vista dell’allocazione fisica dei segmenti in memoria, si può pensare che un processo sia stato suddiviso in un insieme di parti che sono allocate in memoria come avviene con le partizioni a dimensioni variabili e, quindi, si possono avere gli stessi problemi causati dalla frammentazione esterna.</p>\n<h3>Segment Descriptor</h3>\n<p>Nell'indirizzamento della memoria per le architetture di computer Intel x86, i <strong>segment descriptor</strong> fanno parte dell'unità di segmentazione, utilizzata per tradurre un indirizzo logico in un idirizzo lineare (fisico ?).</p>\n<p>I descrittori di segmento descrivono il segmento di memoria a cui fa riferimento l'indirizzo logico. Il descrittore di segmento (lungo 8 byte in 80286 e successivi) contiene i seguenti campi:</p>\n<ol>\n<li>Un indirizzo di base del segmento</li>\n<li>Il limite del segmento che specifica la dimensione del segmento</li>\n<li>Byte dei diritti di accesso contenente le informazioni sul meccanismo di protezione</li>\n<li>Bit di controllo</li>\n</ol>\n<h4>Struttura</h4>\n<ul>\n<li>\n<p><strong>Indirizzo base</strong>, indirizzo di memoria iniziale del segmento. La sua lunghezza è di 32 bit ed è composta dal bit di parte inferiore da 16 a 31 e dal bit di parte superiore da 0 a 7, seguito dai bit da 24 a 31.</p>\n</li>\n<li>\n<p><strong>Limite del segmento</strong>, la sua lunghezza è di 20 bit ed è composta dal Part Bit inferiore da 0 a 15 e dal Part Bit superiore da 16 a 19. Definisce l'indirizzo dell'ultimo dato accessibile. La lunghezza è una in più rispetto al valore memorizzato qui. Il modo esatto in cui questo dovrebbe essere interpretato dipende dal bit di granularità del descrittore di segmento.</p>\n</li>\n<li>\n<p><strong>G=granularità</strong>,</p>\n</li>\n<li>\n<p><strong>D/B</strong>, D = Dimensione dell'operando predefinito B = Big: se impostata, la dimensione massima dell'offset per un segmento di dati viene aumentata a 32 bit</p>\n</li>\n<li>\n<p><strong>L=Lungo</strong> Se impostato, questo è un segmento a 64 bit</p>\n</li>\n<li>\n<p><strong>AVL=Disponibile</strong> Per uso software, non utilizzato dall'hardware (Bit 20 nell'immagine con l'etichetta A)</p>\n</li>\n<li>\n<p><strong>P=Presente</strong> se settato, viene generata un'eccezione &quot;segmento non presente&quot; su qualsiasi riferimento a questo segmento</p>\n</li>\n<li>\n<p><strong>DPL=Livello di privilegio del descrittore</strong> livello di privilegio (anello) richiesto per accedere a questo descrittore</p>\n</li>\n<li>\n<p><strong>Tipo</strong> Se impostato, questo è un descrittore del segmento di codice.</p>\n</li>\n<li>\n<p><strong>C=Conforme</strong> Il codice in questo segmento può essere richiamato da livelli meno privilegiati.</p>\n</li>\n<li>\n<p><strong>E=Espandi-Giù</strong></p>\n</li>\n<li>\n<p><strong>R=Leggibile</strong></p>\n</li>\n<li>\n<p><strong>W=scrivibile</strong></p>\n</li>\n<li>\n<p><strong>A=Accesso</strong></p>\n</li>\n</ul>\n<p>Ogni segmento ha associato una struttura dati gestita dall'hardware, il segment descrittor, i quali sono contenuti in una tabella dei descrittori (caso intel):</p>\n<ul>\n<li>local descriptor table</li>\n<li>Global descriptor table</li>\n</ul>\n<h3>Global Descriptor Table</h3>\n<p>La <strong>tabella dei descrittori globale</strong> o <strong>Global Descriptor Table</strong> (<strong>GDT</strong>) è una struttura dati usata dai processori della famiglia x86 per definire varie aree di memoria nell'esecuzione di un programma, come per esempio l'indirizzo base, la dimensione e i privilegi di accesso come l'eseguibilità e la scrittura. Queste aree di memoria sono chiamate segmenti nella terminologia Intel.</p>\n<p>La GDT contiene altro oltre ai descrittori di segmento. Ogni 8 byte nella GDT rappresentano un descrittore, ma questi possono essere descrittori <a href=\"https://it.wikipedia.org/wiki/Task_State_Segment\">Task State Segment</a> (o TSS), descrittori <a href=\"https://it.wikipedia.org/wiki/Local_Descriptor_Table\">LDT</a>, o descrittori <a href=\"https://it.wikipedia.org/w/index.php?title=Call_gate&amp;action=edit&amp;redlink=1\">Call gate</a>. Gli ultimi, i Call Gate, sono particolarmente importanti per trasferire il controllo tra i vari livelli di privilegi degli x86, anche se questo metodo non è utilizzato dai moderni sistemi operativi.</p>\n<p><img src=\"/Users/davidevigano/Documents/Sicurezza/SicurezzaFoto/GDT1.png\" alt=\"GDT1\"></p>\n<p>ogni segmento ha una label di sicurezza associata</p>\n<p><img src=\"/Users/davidevigano/Documents/Sicurezza/SicurezzaFoto/seg1.png\" alt=\"\"></p>\n<p><img src=\"/Users/davidevigano/Documents/Sicurezza/SicurezzaFoto/Seg2.png\" alt=\"\"></p>\n<p>queste strutture dati vengo inizialliza dal SO, quando ? caricano un processo, aggiorna i descrittori .</p>\n<p>Con queste informazioni l'hardare è in grado di applicare queste policy.<br>\nPer evitare che l'utente vada a modificare dati del SO viene utilizzata la seguente politica:</p>\n<ul>\n<li>soggetto di privilegio C può accedere solo a oggetti D di livello &gt;= C</li>\n</ul>\n<p><strong>Ricorda:</strong></p>\n<ul>\n<li>\n<p>il <strong>DPL</strong> indica il livello di privilegio rispetto alla CPU di quel segmento</p>\n</li>\n<li>\n<p>il <strong>CPL</strong> indica il livello di privilegio corrente.</p>\n</li>\n</ul>\n<p>ogni volta che il processo accede a dei dati all'interno del segmento l'hardware va a vedere se il DPL è &gt;= del CPL se vero autorizza, è una politica mandatoria</p>\n<p>così facendo si vieta a proccessi che operano a ring 3 di andare a ring 0</p>\n<p><strong>Access control</strong></p>\n<ul>\n<li>policy CPL &lt;= DPL</li>\n<li>controllo viene fatto</li>\n</ul>"
                },
                {
                    "subtitle": "Potenziali rischi",
                    "content": "<p>un processo di livello 3 può mandare in esecuzione un processo di livello 0 come ? Tramite syscall</p>\n<p>utente malevolo può manddare sycall per accedere tramite puntatori a porzioni SO</p>\n<p>Soluzione viene introdotto RPL (non approfondire).</p>"
                },
                {
                    "subtitle": "Type checking",
                    "content": "<p>Da una parte blocco chi non è autorizzato e dall'altro chi è autorizzato garantisco che faccia solo cose per cui è autorizzato</p>\n<p>come lo faccio ?</p>\n<p>Ogni descrittore contiene un flag che descrive come e quali operazioni possiamo fare</p>\n<p>Immagine type checking</p>\n<p>bit A per algoritmo di rimpiazzamento (riguardo )</p>\n<p><img src=\"/Users/davidevigano/Documents/Sicurezza/SicurezzaFoto/IMG_6176.png\" alt=\"IMG_6176\"></p>"
                },
                {
                    "subtitle": "Accessing to operating system instruction",
                    "content": "<p>quello che abbiamo viesto policy livello Hardware</p>\n<p>come faccio a proteggere user dallo user → è sempre l'hardware tramite MMU, i processi hanno spazi di indirizzamento diversi</p>\n<p>il meccanismo che abbimo visto finora serve per proteggere i dati da accessi diretti.</p>\n<p>cosa succede se faccio jump ?</p>\n<p>trasfermito di controllo tra processi avviene solo tra processi che hanno lo stesso liviello di privilegi CPL = DPL, questo vuol dire che nemmeno ring 0 può saltare all'interno di ring 3 perchè:</p>\n<ul>\n<li>problema quando si torna indietro liv 0 jump liv 3 e poi liv 3 liv 0 dovrebbero introdurre eccezioni</li>\n<li>salto può fare casini, ritonra indietro corrotti</li>\n</ul>\n<p>blocco questo tipo di passaggi a livelli hardware</p>\n<p>eccezione alla regola sono le controller invocation, hw consente process liv 3 a codice di livello 0 se rispetta controller invocation</p>\n<p>uno di questi è la system call, vengo controllato, posso fare solo alcune cose</p>\n<ul>\n<li><strong>call gate</strong></li>\n<li><strong>software interrupt o trap</strong> Interruzione software per passare User Mode to Kernel Mode e viceversa</li>\n<li><strong>Sysenter  , sysexit</strong> interruzione assembly per passare User Mode to Kernel Mode e viceversa ( più performante)</li>\n</ul>"
                },
                {
                    "subtitle": "Gate",
                    "content": "<p>contiene l'indirizzo del codice del kernel a cui possiamo saltare.</p>\n<p>sono raccolti in una tabella, il SO quanto parte carica questa tabella (interrupt descriptor table) in cui il SO carica tutti i punti d'accesso per le syscall</p>\n<p>sono cablate a livello di Hardware</p>\n<p><img src=\"/Users/davidevigano/Documents/Sicurezza/SicurezzaFoto/IMG_6178.png\" alt=\"IMG_6178\"></p>\n<p><strong>System Call</strong></p>\n<p>Una <strong>System Call</strong> indica il meccanismo usato da un processo a livello utente o livello applicativo, per richiedere un servizio a livello kernel del sistema operativo del computer in uso.</p>\n<p>è l'unico meccanismo con cui una applicazione può richiedere un servizio al kernel.<br>\nCome avviene:</p>\n<ul>\n<li>Salvataggio registri</li>\n<li>Commuta user mode →   kernel mode.</li>\n<li>Esegue una funzione di servizio.</li>\n<li>Copia opzionalmente dati in memoria utente</li>\n<li>Commuta kernel mode → user mode.</li>\n<li>Ripristino registri ed esecuzione programma</li>\n</ul>\n<p>Processo può saltare solo tramite gate e una volta che è dentro esegue una syscall che è blindata</p>"
                },
                {
                    "subtitle": "Log file",
                    "content": "<p>Generati dal sistema, danno origine al processo di Audit, processo legato all'esaminazione e alle valutazione dellle attività svolte.</p>\n<ul>\n<li>serve per vedere se le policy sono implementate correttamente</li>\n<li>verificare efficenza del sistema</li>\n</ul>\n<p>dal nostro punto di vista parliamo di d'analisi del sistema per verificare la sua adernza con la politica di sicurezza</p>\n<p>raccolta file di log op precedente a Audit</p>\n<p><strong>componenti dell' audit</strong></p>\n<ul>\n<li>Raccolta delle informazioni, devo garantire che non vengano modificati</li>\n<li>analisi dei dati per scoprire o diagnosticare violazioni della sicurezza, può essere fatta :\n<ul>\n<li>post motem</li>\n<li>in tempo reale</li>\n</ul>\n</li>\n</ul>\n<p>il file di log diventa una sentinella per vedere andamento del sistema.</p>\n<p>ogni sistema operativo raccoglie i suoi faile di log, in linux vengono salvati tutti sulla directory /var/log</p>\n<p>problema i file di log crescono a dismisura, vanno previste delle politiche, si assegna dimensione massima quando finisce si inizia da capo.</p>"
                },
                {
                    "subtitle": "Syslog",
                    "content": "<p>Syslog, noto anche come System Logging Protocol, è un protocollo standard utilizzato per inviare messaggi di eventi o log di sistema a un particolare server, il server Syslog. Syslog viene utilizzato principalmente per raccogliere diversi registri di dispositivi da varie macchine e archiviarli in una posizione centrale per il monitoraggio e la revisione.</p>\n<p>Syslog è uno standard di registrazione basato sull'organizzazione utilizzato per le applicazioni per inviare informazioni a un server locale, fornendo dati. A differenza di SNMP,  il monitoraggio Syslog offre una metodologia distaccata, che consente alle organizzazioni di gestire gli episodi dopo che si sono verificati. I blackout sono a volte inevitabili; tuttavia, una soluzione di monitoraggio Syslog convincente può accelerare la misura di controllo del danno, risparmiando minuti o anche lunghi periodi di tempo e personale.</p>\n<p>il log possono essere memorizzati in locali o in remoto</p>\n<p>genera messaggi predefiniti dallo standard</p>\n<p><img src=\"/Users/davidevigano/Documents/Sicurezza/SicurezzaFoto/09fig02.png\" alt=\"\"></p>\n<p>è possibile modifica il dormato dei file di log</p>\n<p>come faccio a leggere file di log</p>\n<p>2 formati:</p>\n<ul>\n<li>caratteri Cat , more, less , tail head, grep</li>\n<li>binary :</li>\n</ul>\n<p>come si fa analisi dei faile di log, manualmente si fa con la grep</p>\n<p>ci sono società che fanno analisi di log dato che software costano molto</p>\n<p>non ha più senso che i log vengono conservati su una macchina sola, esistono dei tool di centrallizzazione dei log.</p>\n<p>sono oggetti automatici, non sempre ci prendono, può capitare che non si accorgono di un attacco in corso e questo punto bisogna analizzarli manualmente.</p>\n<p>nel modo unix i file di log ha fatto un salto di qualità con il journald</p>\n<h3>System-jouranld</h3>\n<p>Journald è un servizio di sistema per la raccolta e l'archiviazione dei dati di Log, introdotto con systemd. Cerca di rendere più facile per gli amministratori di sistema trovare informazioni interessanti e pertinenti tra una quantità sempre crescente di messaggi di Log.</p>\n<p>In linea con questo obiettivo, uno dei principali cambiamenti in journald è stato quello di sostituire i semplici file di log in testo normale con uno speciale formato di file ottimizzato per i messaggi di log. Questo formato di file consente agli amministratori di sistema di accedere ai messaggi pertinenti in modo più efficiente.</p>\n<p>Raccoglie tutti i file di log nel suo DB (relazionale) e consente la manipolizzazione tramite query SQL</p>\n<h3>Log management system</h3>\n<p>La gestione dei registri è la pratica di raccogliere, archiviare, elaborare, sintetizzare e analizzare continuamente dati da programmi e applicazioni disparati al fine di ottimizzare le prestazioni del sistema, identificare problemi tecnici, gestire meglio le risorse, rafforzare la sicurezza e migliorare la conformità.</p>\n<p>La gestione dei log di solito rientra nelle seguenti categorie principali:</p>\n<ol>\n<li><strong>Raccolta:</strong> uno strumento di gestione dei registri che aggrega i dati dal sistema operativo, dalle applicazioni, dai server, dagli utenti, dagli endpoint o da qualsiasi altra fonte pertinente all'interno dell'organizzazione.</li>\n<li><strong>Monitoraggio:</strong> gli strumenti di monitoraggio dei registri tengono traccia di eventi e attività, nonché di quando si sono verificati.</li>\n<li><strong>Analisi:</strong> strumenti di analisi dei registri che esaminano la raccolta dei registri dal server dei registri per identificare in modo proattivo bug, minacce alla sicurezza o altri problemi.</li>\n<li><strong>Conservazione:</strong> uno strumento che indica per quanto tempo i dati di registro devono essere conservati all'interno del file di registro.</li>\n<li><strong>Indicizzazione o ricerca:</strong> uno strumento di gestione dei registri che aiuta l'organizzazione IT a filtrare, ordinare, analizzare o cercare i dati in tutti i registri.</li>\n<li><strong>Reporting:</strong> strumenti avanzati che automatizzano i report dal registro di controllo in relazione a prestazioni operative, allocazione delle risorse, sicurezza o conformità alle normative.</li>\n</ol>\n<p><strong>SIEM</strong></p>\n<p>Questo tipo di soluzioni ha come obiettivo la raccolta centralizzata dei log e degli eventi generati da applicazioni e sistemi in rete. Grazie al machine learning le attività di correlazione e monitoraggio sono potenziate, abilitando una security intelligence evoluta</p>\n<p>Il SIEM è una soluzione in cui convergono Security Information Management e Security Event Management. Più in dettaglio:</p>\n<ul>\n<li>Il <strong>SIM</strong> è un sistema di gestione delle informazioni che automatizza il processo di raccolta e orchestrazione dei log (ma non in tempo reale). I dati vengono raccolti e spediti ad un server centralizzato tramite l’utilizzo di software agent installati sui vari dispositivi del sistema monitorato. La possibilità di usufruire di spazi di archiviazione a lungo termine unita all’analisi dei dati consente la generazione di report personalizzati.</li>\n<li>Il <strong>SEM</strong> è una soluzione software che, in tempo reale, provvede al monitoraggio e alla gestione degli eventi che accadono all’interno della rete e sui vari sistemi di sicurezza, fornendo una correlazione e aggregazione tra essi. L’interfaccia è una console centralizzata, preposta ad attività di monitoraggio, segnalazione e risposta automatica a determinati eventi.</li>\n</ul>\n<p>Agganciando al SIM il SEM, il SIEM analizza i registri raccolti per evidenziare eventi o comportamenti di interesse consentendo, ad esempio, di rilevare un accesso amministrativo al di fuori del normale orario di lavoro, quindi informazioni sull’host, sull’Id e altro ancora. Le informazioni contestuali raccolte rendono i report estremamente più dettagliati e permettono di ottimizzare i flussi di lavoro finalizzati alla risoluzione degli incidenti.</p>\n<p>Come funziona una soluzione di Security Information and Event Management ?</p>\n<p>La tecnologia dei sistemi SIEM ha come obiettivo la raccolta centralizzata dei log e degli eventi generati da applicazioni e sistemi in rete, per consentire agli analisti di sicurezza di ridurre i tempi necessari alla risoluzione e alle indagini su allarmi e incidenti di sicurezza.</p>\n<p>Le principali attività di un SIEM sono raccogliere, analizzare, correlare e monitorare un elevato numero di dati diversificati, provenienti da:</p>\n<ul>\n<li><strong>Strumenti di sicurezza</strong></li>\n<li><strong>Dispositivi di rete:</strong> router, switch, DNS server</li>\n<li><strong>Apparati:</strong> dispositivi degli utenti, server di autenticazione, database</li>\n<li><strong>Applicazioni:</strong> applicazioni intranet, applicazioni web, applicazioni Saas</li>\n</ul>\n<p>Il principio chiave del SIEM è un monitoraggio evoluto, basato sulla capacità di aggregare dati significativi, provenienti da molteplici fonti, stabilendo in tempo reale analisi e correlazioni finalizzate a individuare comportamenti anomali, segnali critici e a generare allarmi.<br>\nArricchiscono il log con info della rete, alzando livelli di rischio ex su porte aumentandone il livello accedento persino al dark-web e recuperare pswrd compromesse dell'azioenda.</p>"
                }
            ]
        },
        {
            "title": "Malware",
            "sections": [
                {
                    "subtitle": "Introduzione",
                    "content": "<p>introduce un novo concetto, non cerco bug all'interno del sistema per poter inniettare il codice, ma creo un programma a doc convincendo l'utente a eseguirlo (intenzionamente o non )</p>\n<p>cosa può fare un malware ? fa esattamente tutto quello che può fare l'utente che lo ha mandato in esecuzione</p>\n<p>in windows si evidenzia un grosso problema in termini di sicurezza che può essere sfruttato da un Malware ovvero:  un utente spesso è amministratore</p>\n<p>esistono diversi tipi di malware e  possono essere classificati secondo diversi parametri:</p>\n<p><strong>Propagazione</strong></p>\n<ul>\n<li><strong>virus</strong> ci deve essere una qualche azione da parte di umano (ex cliccare su qualcosa)</li>\n<li><strong>worm</strong> propagazione automatica senza intervento umano</li>\n</ul>\n<p><strong>Occultamento</strong></p>\n<ul>\n<li><strong>Rootkit</strong> modifica le operazioni di sistema per nascondere la sua esistenza</li>\n<li><strong>Trojan</strong> inganna l'utente con funzionalità desiderabili ma fa operazioni malevole</li>\n</ul>\n<p><strong>Payloads</strong><br>\nvanno dal fastidio al crimine</p>\n<p>all'interno del malware si parla di <strong>bombe logice</strong> , tipicamente sono virus, sono dei meccanismi che scattano a tempo, il malware è silente, si verifica una certa condizione e parte.</p>"
                },
                {
                    "subtitle": "Info extra",
                    "content": "<p><img src=\"/Users/davidevigano/Documents/Sicurezza/SicurezzaFoto/Malware.png\" alt=\"Malware\"></p>\n<h3>Trojan</h3>\n<p>I trojan si propagano attraverso social engenieering . Celandosi sotto mentite spoglie, il trojan convince l'utente ignaro a installarlo. Uno dei metodi di attacco più comuni consiste nell'indurre l'utente ad aprire un file o un collegamento web che installa malware (virus in questo caso). Ad esempio, i trojan come gli scareware possono convincere l'utente che un certo programma protegga il suo computer, mentre in realtà fa l'opposto.</p>\n<p>In altri casi, l'utente può installare una simpatica barra degli strumenti per il browser o una divertente tastiera per emoji, che tuttavia contiene anche malware. Un'altra tecnica utilizzata dai trojan prevede la scrittura di malware di tipo autoinstallante su una chiavetta di memoria USB (o unità USB) da consegnare all'utente. I malware Remote Access Trojan (RAT) consentono ai criminali informatici di controllare i dispositivi da remoto dopo esservisi infiltrati.</p>\n<h3>Worm</h3>\n<p>I worm si insinuano in aree a cui non dovrebbero accedere. Il primo worm informatico sperimentale, che si limitava ad autoreplicarsi, è stato introdotto negli anni '70. Negli anni '80 hanno fatto la comparsa worm più dannosi, i primi virus informatici ampiamente conosciuti, che si diffondevano da un PC all'altro attraverso i floppy disk e danneggiavano i file a cui avevano accesso. Con la diffusione di Internet, hacker e sviluppatori di malware hanno iniziato a progettare worm capaci di replicarsi attraverso la rete, che hanno costituito la prima minaccia per la sicurezza delle aziende e degli utenti connessi a Internet.</p>\n<h3>Exploit</h3>\n<p>Un exploit è una vulnerabilità del software che può essere utilizzata illegalmente per indurlo a compiere operazioni non previste dalla sua progettazione. Il codice malware potrebbe utilizzare un exploit per entrare in un sistema o per spostarsi all'interno del sistema. Molti exploit si basano su vulnerabilità note (le cosiddette <a href=\"https://www.redhat.com/it/topics/security/what-is-cve\">CVE</a>, Common Vulnerabilities and Exposures), sfruttando il fatto che non tutti gli utenti applicano regolarmente le patch di sicurezza ai propri sistemi. Più raramente, un exploit zero day approfitta di una vulnerabilità critica che non è stata corretta dal responsabile della manutenzione del software.</p>\n<h3>Phishing</h3>\n<p>Il phishing è un tipo di attacco basato sull'ingegneria sociale nel quale un utente viene indotto a fornire informazioni sensibili o dati personali tramite una richiesta ingannevole, ad esempio una falsa email o un'offerta che in realtà ha lo scopo di truffarlo. Essendo una strategia per ottenere password e credenziali di accesso, gli attacchi di phishing anticipano a volte un attacco malware.</p>\n<h3>Rootkit e bootkit</h3>\n<p>Un rootkit è costituito da una serie di strumenti software espressamente progettati per assumere il controllo completo di un sistema e cancellare le proprie tracce. I rootkit sostituiscono efficacemente i normali controlli amministrativi del sistema. Un bootkit è un rootkit avanzato che infetta un sistema a livello di kernel, acquisendo un grado di controllo addirittura superiore, ed è più difficile da rilevare.</p>\n<h3>Adware e spyware</h3>\n<p>L'adware ingombra il dispositivo con annunci pubblicitari indesiderati, come pop-up nel browser web. Lo spyware, molto simile all'adware, raccoglie le informazioni dell'utente e le trasmette ad altri sistemi. Le tipologie di spyware possono variare dai tracker, che monitorano l'attività Internet dell'utente, a sofisticati strumenti di spionaggio. Tra gli spyware ci sono i keylogger, strumenti in grado di registrare tutto ciò che viene digitato sulla tastiera. Sia spyware che adware non solo violano la privacy dell'utente, ma possono anche rallentare il sistema e congestionare la rete.</p>\n<h3>Botnet</h3>\n<p>I botnet consentono a un utente esterno di assumere il controllo del dispositivo, che entra a fare parte di una vasta rete di dispositivi infetti. Solitamente i botnet vengono utilizzati per sferrare attacchi DDoS (Distributed Denial of Service), inviare spam o cercare <a href=\"https://en.wikipedia.org/wiki/Cryptocurrency\">criptovaluta</a>. Qualunque dispositivo non protetto connesso in rete può essere vulnerabile a un'infezione. I botnet dispongono in genere di strumenti per espandere la propria rete di dispositivi e sono abbastanza complessi da eseguire varie attività nocive, contemporaneamente o in sequenza. Ad esempio il malware <a href=\"https://en.wikipedia.org/wiki/Mirai_(malware)\">Mirai</a>, nell'attacco del 2016, ha utilizzato webcam connesse a Internet e router domestici per formare un enorme botnet DDoS.</p>\n<h3>Ransomware</h3>\n<p>Il ransomware è un codice malware che esige un pagamento. Molti dei tipi di ransomware più comuni crittografano i file nel sistema di un utente ed estorcono il pagamento di un riscatto in Bitcoin in cambio di una chiave di decifratura. Il ransomware è venuto alla ribalta a metà degli anni 2000 ed è rimasto da allora una delle minacce più gravi e diffuse alla sicurezza informatica.</p>\n<h3>Altri danni</h3>\n<p>A volte, lo sviluppatore o l'operatore di malware ha lo scopo di distruggere dati o danneggiare componenti o servizi. Molti anni prima che il ransomware diventasse un problema, uno dei primi programmi malware ad attirare l'attenzione dei media è stato il <a href=\"https://en.wikipedia.org/wiki/Michelangelo_(computer_virus)\">virus Michelangelo</a>, nel 1992, che tentava di sovrascrivere l'unità disco del PC infetto in una data specifica, il 6 marzo. Alcuni anni dopo, nel 2000, il <a href=\"https://en.wikipedia.org/wiki/ILOVEYOU\">virus ILOVEYOU</a> si è diffuso da un utente all'altro sotto forma di script Visual Basic inviato come allegato email. Quando veniva eseguito, questo virus cancellava diversi file e inviava una copia di sé stesso per email a tutti i contatti nella rubrica dell'utente.</p>\n<p>Rispetto agli standard del malware moderno, questi virus sembrano addirittura ingenui. Prendiamo come esempio <a href=\"https://en.wikipedia.org/wiki/Stuxnet\">Stuxnet</a>. Nel 2010 la security community ha scoperto un worm enigmatico e altamente sofisticato, progettato per manomettere un tipo specifico di apparecchiatura industriale. <a href=\"https://www.vice.com/en_us/article/ezp58m/the-history-of-stuxnet-the-worlds-first-true-cyberweapon-5886b74d80d84e45e7bd22ee\">Molti esperti di sicurezza oggi ritengono che</a> Stuxnet sia stato progettato dai governi di Stati Uniti e Israele per sabotare il programma nucleare iraniano, sebbene nessun governo se ne sia assunto ufficialmente la responsabilità. Se tale ipotesi fosse vera, questo sarebbe un esempio di malware emergente, ovvero un tipo di attacco informatico sponsorizzato da uno stato.</p>"
                },
                {
                    "subtitle": "Differenza tra Computer Virus e Malware",
                    "content": "<p><strong>computer virus</strong> è un codice che si replica (segue andamento virus biologici), la copia viene effettuata all'interno di altri programmi, la prima cosa di cui si proccupa è la soppravvivenza successivamente fa quello per cui è stato programmato (l'utene svolge un ruolo fondamentale).</p>\n<p><strong>un virus opera in fasi</strong></p>\n<ul>\n<li>prima fase sta <strong>tranquillo</strong> per non farsi bloccare</li>\n<li>incomincia a <strong>infettare</strong> il sistema</li>\n<li>verifica se ci sono le condizioni per fare ciò per cui è stato creato e a questo punto <strong>attacca</strong></li>\n</ul>\n<p>si distingue in:</p>\n<ul>\n<li><strong>residente</strong>  tipo di virus che si nasconde e si archivia nella memoria del computer, che gli consente quindi di infettare qualsiasi file eseguito dal computer</li>\n<li><strong>non-residente</strong> deve essere eseguito per poter infettare</li>\n</ul>\n<p><strong>Differenza:</strong><br>\nI virus residenti sono in contrasto con i virus non residenti, che sono virus eseguibili, il che significa che devono essere eseguiti prima di poter infettare, diversamente dal virus residente che può essere eseguito ogni volta che il sistema operativo viene caricato.</p>\n<p>tipicamente i virus vengono messi sul <strong>boot sectors</strong> (settore 512 byte, settore numero 0 del disco, in sostanza ha il compito di caricare il sistema operativo), se riesco inffettarlo ogni volta accendo la macchina il virus viene caricato</p>\n<p>qualunque file esegublle può contenere un malware</p>"
                },
                {
                    "subtitle": "Esempio Malware",
                    "content": "<p>virus pyton, va a cercare le vittime da infettare<br>\ncostruisce una lista di file da infettare che sono sotto una directory<br>\nscorre l'albero<br>\nva cercare tra i file quelli che hanno .py e li invia a una a una funzione che li infetta</p>\n<p><em>guardo foto</em></p>"
                },
                {
                    "subtitle": "Obbiettivo del malware",
                    "content": "<p>il malware deve nascondersi dall'antivirus</p>\n<p>un'altro meccanismo è quello di fare un virus che muti, per rendere più difficile individuazione dall'antivirus esistono 3 strategie</p>\n<ul>\n<li>\n<p><strong>Encrypted virus</strong>, <em>ex: ransomware che prolifera tramite e-mail spam</em><br>\nil virus viene cifrato, la chiave di cifratura viene continuamente modificata, si può ancora scovare cifratura e decifratura la quale deve essere in chiaro per poter essere eseguito</p>\n<p>pezzetto di virus in chiaro</p>\n</li>\n<li>\n<p><strong>Polymorphic virus</strong> contengono all'interno funzioni di decifratura che si auto-modificano, → rende virus diverso (non più intercettabile tramite signaturs) , come trovarli ? antivirus esegue il programma nuovo all'interno di una sua macchina virtuale e viene analizzato il comportamento, viene riconosciuto in base alle azioni che svolge</p>\n</li>\n<li>\n<p><strong>Metamorphic virus</strong> modificano tutto, anche le azioni che fanno → problema complessi da scrivere</p>\n</li>\n</ul>\n<p>dato che motamorfi complessi virus polimorfi cercano di capire se sono in esecuzioni su una macchina virtuale così da ingannare l'antivirus</p>"
                }
            ]
        },
        {
            "title": "Worm",
            "sections": [
                {
                    "subtitle": "intro",
                    "content": "<p>nascono più tardi dei malware, si sviluppano con l'ingresso di microsoft sulla rete (1993)</p>\n<p>primo <em>I love you</em> , era più simile ad un virus ed era inviato tramite mail, richiedeva un intervento umano per partire</p>\n<p><strong>Caratteristica di un worm</strong> : non ha bisogno di un intervento umano, si autoriproduce, deve avere una rete che gli consente di passare da un host all'altro, tipicamente sfrutta vurnerabilità presenti sulla rete entra come bufferoverflow, vede macchine collegatata con quella e infetta le altre</p>\n<ul>\n<li><strong>identificare vulnerabilità</strong> di un servizio di rete</li>\n<li>si <strong>compromette la vulnerabilità</strong>, in base al tipo si acquisisce una sheel (tramite bufferoverflow)</li>\n<li>crea una <strong>lista di ip da attaccare</strong> (tramite shell va ad infettare altre macchine )</li>\n<li>esegue il payload, <strong>installa un demone</strong> che riceve comandi dall'esterno</li>\n</ul>\n<p>Worm, è un virus + una parte di exploir (virus automatizzato).</p>\n<p>chi fa worm non ha bisogno di nascondersi come il malware il worm non deve convincere l'utente a fare un azione che non farebbe</p>"
                },
                {
                    "subtitle": "Tecniche d'attacco",
                    "content": "<p>2 tecniche d'attacco, prima poco tecnolocica ma molto efficace</p>\n<p>l'obbiettivo è convincere un utente a fare azioni che non dovrebbe fare</p>\n<ul>\n<li>\n<p><strong>social Engignering</strong>, è un isieme di tecniche (sociale) di manipolazione delle persone per convincerle a fare cose che ragionevolmente non avrebbero mai fatto.<br>\nsi basa su un meccanismo che abbiamo ereditato dai nostri antenati, l'eurustica, meccanismo che il nostro cervello mette in atto in un momento che siamo in situazione d'emergenza, stress, facendoci agire d'impulso, mettendo in opera meccanismi che abbiamo ereditato attraverso regole empiriche.<br>\nL'euristica meccanismo che porta a fare azione diversa in situazione di calma dettata da esperienze pregresse.</p>\n<p><em>ex i love you sfrutta questo meccanismo</em></p>\n<p><strong>quando scatta euristica:</strong></p>\n<ul>\n<li>sovraccarico di informazioni</li>\n<li>poche informazioni</li>\n<li>deve decidere difrettta -→ genralmente viene usata questa</li>\n</ul>\n<p>euristica introduce anche dei pregiudizzi cogntivi</p>\n<p>molti attacchi di fishing vengono fatte in orari notturni sfruttando l'affaticamento decisionale</p>\n<p>portano a decisioni sbagliate</p>\n<p>la vittima deve essere sottopressione, una volta che riusciamo a creare questo stato, questa persona non operarerà più razionalmente ma sotto euristica, commetterà degli errori che verranno sfruttati</p>\n<p>I worm che si basano sulla tecnica di social engignering sono il :</p>\n<ul>\n<li>\n<p><strong>phishing</strong> solitamente è fatta per raccogliere informazioni,</p>\n<ul>\n<li>username pswrd</li>\n<li>residenza</li>\n<li>carta di credito</li>\n<li>...</li>\n</ul>\n<p>esistono diversi tipi di phishing</p>\n<ul>\n<li><strong>mass phishing:</strong> mail mandate in modo massivo e si spera che qualcuno abbocchi</li>\n<li><strong>spaer phishing:</strong> atatacco diretto, puo essere ulteriormente raffinato:\n<ul>\n<li><strong>whaling:</strong> diretto ai pesci grossi</li>\n</ul>\n</li>\n<li><strong>clone</strong></li>\n<li><strong>sdvance fiscal</strong></li>\n</ul>\n<p>realtà virtuale si sovrappone con quella reale</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Dictionary attack</strong></p>\n<p>forma d'attacco basati su meccanismi con password</p>\n<p>una persona che vuole utilizzare un sistema o un servizio deve prima farsi riconoscere da questultimi</p>\n<p>gli utenti vengono individuati attraverso un identificatore (ex mail )<br>\nil sistema vuole sapere poi se siamo effettivamente noi (vuole dimostrazione) chiedendo la passsword</p>\n<p>2 processi:</p>\n<ul>\n<li><strong>identificazione</strong></li>\n<li><strong>autenticazione</strong></li>\n</ul>\n<p>3 meccanismi</p>\n<ul>\n<li><strong>ciò che sai</strong>, identificazione tramite pswrd</li>\n<li><strong>ciò che hai</strong>, devi dimostrare di possedere qualcosa che tu hai (ex carta di credito)</li>\n<li><strong>ciò che sei</strong>, meccanismo autenticazione biometrica</li>\n</ul>\n<p>la pswrd è un segreto che condividiamo con il sistema<br>\nogni sitema protegge le nostre password, viene memorizzata sul sistema in maniera cifrata, nemmeno root conosce la password in chiaro</p>\n<p>Inserimento password:</p>\n<ul>\n<li>\n<p>digito password</p>\n</li>\n<li>\n<p>viene applicato algoritmo di hashing</p>\n</li>\n<li>\n<p>viene memorizzata hashata</p>\n</li>\n</ul>\n<p>per confrontare pswrd inserita fa hash di quest'ultima e la  confronta con quella memorizzata, se trova la corrispondenza allora la password è corretta</p>\n<p>questo è un sistema teoricamente infallibile ma che praticamente risulta pieno di bachi, perchè è un sistema utilizzato male, il problema sono gli utenti che non sanno scgliere le password.<br>\nE' il classico sistema che inserito nel mondo reale non funziona adeguatamente.</p>\n<p>due strategire per attaccare le pswrd:</p>\n<ul>\n<li>\n<p>**low tech ** tramite social engenieering</p>\n</li>\n<li>\n<p><strong>high tech</strong> (cerchiamo di bucare etc shadow)</p>\n<ul>\n<li>\n<p><strong>exhaustive</strong> <strong>search</strong> provo tutti i carattteri (ricerca esaustiva), probleama molto lunga</p>\n</li>\n<li>\n<p><strong>dictionary</strong> <strong>attack</strong>: viene raccolto un db diparole frequenti usate in un certo contesto, il programma prende queste parole le cifra e confronta il risultato, password gessing<br>\ncalcola hash della pswrd da provare con la password di etc/shadow (satistiche 20% di successo)</p>\n</li>\n<li>\n<p><strong>Raynbow attack</strong>: prende un dizionario fa hashing ofline e confronta con hash del file etc/shadow</p>\n<p>lo si frega inserendo il salt (sequenza casuale di bit che poi messa insieme, tramite una funzione, con la pswrd hashata) per superrarlo il dizionario lo devo creare con tutti i possibili salt<br>\nPswrd + salt → etc/shadow</p>\n<p>il salt è casuale cambia per ogni utente, ma è noto, non segreto, quindi non da problemi a dictionary</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>"
                }
            ]
        },
        {
            "title": "Password cracking - john the ripper",
            "sections": [
                {
                    "subtitle": "john the ripper",
                    "content": "<ul>\n<li>\n<p>cat file /etc/passwd<br>\nls usa questo file per funzionare, ci sono tutti i dati dell'utente<br>\n<img src=\"/Users/davidevigano/Documents/Sicurezza/SicurezzaFoto/etc:paswd.jpeg\" alt=\"etc:paswd\"></p>\n</li>\n<li>\n<p>/etc/shadow<br>\ncontiene la password vere, non in chiara ma hashata indicata con quale algoritmo viene hashata  $1$ ex</p>\n<p>se voglio hash ultimo pezzo dopo il dollaro</p>\n</li>\n</ul>\n<p>john the ripper è un tool che si occuopa ti craccare le password</p>\n<p>4 modi</p>\n<ul>\n<li>\n<p>single mode, prende una entry del file delle pswrd e va a fare delle piccole permutazioni tra il nome utente e altri dati e prova craccare la password ex nome luca e pswrd luca123 la cracca</p>\n<pre><code>john mypassword --single\n</code></pre>\n</li>\n<li>\n<p>word list, ovvero il dictionary attack, lista di possibili password</p>\n<pre><code>john mypassword --wordlist=file.txt\n</code></pre>\n</li>\n<li>\n<p>Incremental</p>\n</li>\n<li>\n<p>extarnal, come vogliamo che la nostra password sia formata</p>\n</li>\n</ul>\n<p>perchè ho $y$</p>\n<pre><code>--format=crypto\n</code></pre>\n<pre><code>sudo unshadow training-passwd.txt training-shadow.txt &gt; mypassword\n</code></pre>"
                },
                {
                    "subtitle": "Provo Worm",
                    "content": "<p>avrò un worm scritto in pyton, con un doc config simula server attattaccante e server utente, il worm si colleghera tramite ssh e proverà a prendere alcune info e mandarle al server dell'attaccante.</p>\n<p><em>file github</em></p>\n<h3>AbramWorm</h3>\n<ul>\n<li>parte e cerca degli host vulnerabili</li>\n<li>cerca di connettersi con ssh, per farlo ci vuole una pswrd e un user, faccio la stessa cosa che ho fatto con john</li>\n<li>lancia un ls, per vedere se c'è una copia di se stesso, se non c'è si copia, fa esfiltrazione, toglie alcuni file che sono interesanti per l'attaccante</li>\n<li>manda i file al server dell'attacante tramite upload</li>\n</ul>"
                }
            ]
        },
        {
            "title": "Network Security",
            "sections": [
                {
                    "subtitle": "Obiiettiovo",
                    "content": "<p>L'obbiettivo degli attaccanti è quello di impossessarsi di beni delle persone &quot;oneste&quot;</p>\n<p>nel campo cybernetico ci sono diverse tematiche di sicurezza</p>\n<ul>\n<li><strong>system security</strong>, l'attaccante risiseda sulla macchina che attacca</li>\n<li><strong>network security</strong>, individua tecniche e meccanismi per la rete, studia tecniche d'attacco per la rete.</li>\n<li><strong>Web security</strong>, ulteriore specializzazione della network, astrae la rete</li>\n</ul>\n<p>l' obbiettivo è violare</p>\n<ul>\n<li><strong>Confedenzialità</strong></li>\n<li><strong>Integrità</strong></li>\n<li><strong>Disponibilità</strong></li>\n</ul>\n<p>una rete è un insieme di host collegati tra loro, gli host comunicano scambiandosi i messaggi, i formati e le modalità sono predeterminati da protocolli.</p>\n<p>componenti fondamentali:</p>\n<ul>\n<li>Host</li>\n<li>apparati attivi (route switch) → instradamento</li>\n<li>Canali di comunicazioni</li>\n</ul>\n<p>i calcolatori sono collegati alla rete tramite scheda di rete, può comunicare in più modi (cavo, wifi), i pacchetti che lasciano il pc escono dalla scheda di rete, sia internet che wi-fi sono protocolli basati su brotcast</p>\n<p>sulla rete internet ogni host ha almeno 2 indirizzi</p>\n<ul>\n<li><strong>mac address (indirizzo fisico),</strong> dato dal costruttore, codice univoco che identifica la scheda di rete  (48bit)</li>\n<li><strong>indirizzo IP (indirizzo logico)</strong> che viene assegnato dinamicamente (in rari casi è statico)</li>\n</ul>\n<p>le modalità di comunicazioni tra 2 host possono essere effettuate tramite</p>\n<ul>\n<li><strong>Connectionless UDP</strong></li>\n<li><strong>Connection-oriented TCP</strong> (syn, ack, syn_ack)</li>\n</ul>\n<p>sistema layerizzato, protoccolli livello più alto utilizzano quelli di livello più basso, hanno però protocolli diversi, soluzione incapsulamento</p>\n<p><img src=\"/Users/davidevigano/Documents/Sicurezza/SicurezzaFoto/pacchettoLiv7.jpg\" alt=\"\"></p>\n<p><img src=\"/Users/davidevigano/Documents/Sicurezza/SicurezzaFoto/rete.jpeg\" alt=\"rete\"></p>\n<p><strong>ARP</strong> mapping tra indirizzo logico e indirizzo fisico</p>\n<p>manda ARP request in broadcast, per sapere indirizzo fisico associato a quello logico, l'host corrispondente manderà un ARP require con il quale comunicherà il suo mac addres (indirizzo fisico)</p>\n<p>In termini di sicurezza in <strong>network security</strong> vengono introdotti nuovi asset che possono essere utilizzati dagli atacker</p>\n<ul>\n<li><strong>Canali di comunicazioni</strong></li>\n<li><strong>Network device</strong>: router ...</li>\n<li><strong>protocolli di comunicazione</strong> → si trovano nel sistema operativo (vengono fatte system call)</li>\n<li><strong>Appplicazoni di rete</strong> ex ssh sftp http ...</li>\n</ul>\n<p>sono nuove fonti di vulnerabiltà e quindi di attacco</p>\n<p>tipicamente gli attacchi su una rete sono ( maggiorparte degli attacchi ha come obbiettivo l'intercettazione del traffico )</p>\n<ul>\n<li><strong>attacchi passivi</strong> è l'intercettazione, obbiettivo leggere cotenuto dei messaggi, oppure analisi de traffico</li>\n<li>**attacchi attivi ** MITM, TCP, hijacking, dos/DDOS</li>\n</ul>\n<pre><code class=\"language-mermaid\">graph TD;\n    Attack--&gt; passivo;\n    Attack--&gt;attivo;\n    passivo--&gt;intercettare;\n    intercettare--&gt;leggere_contenuto;\n    intercettare--&gt;analisi_del_traffico;\n    attivo--&gt; MITM;\n    attivo--&gt; TCP;\n    attivo--&gt; hijacking;\n    attivo--&gt; dos/DDOS;\n</code></pre>\n<p>il primo problema che si pongono gli attaccanti è quello di nascondere il prorpo indirizzo IP, quindi devo cambiare il mio indirizzo IP come faccio con → <strong>spoofing</strong></p>\n<h3>Spoofing</h3>\n<p>consiste nel nascondere la vera identità chi sta effettuando l'attacco</p>\n<p>è un elemento fondamentale per l'attacco (bisogna farlo prima di ogni attacco)</p>\n<p>problema devo tener conto del <strong>blind spoofing</strong>, non sono in grado di controllare la comunicazione con TCP (syn, ack, syn_ack)</p>\n<h4>Blind spoofing</h4>\n<p>In questo tipo di attacco, l'attaccante trasmette più pacchetti al suo obiettivo previsto per ricevere una serie di numeri che sono generalmente utilizzati per assemblare i pacchetti nell'ordine in cui intendevano leggerli. cioè, nell'ordine in cui il pacchetto 1 deve essere letto per primo, quindi il pacchetto 2 e infine il pacchetto 3. In questo attacco, l'hacker non è a conoscenza di come avvengono le trasmissioni su questa rete, quindi deve convincere la macchina a rispondere alla sua proprie richieste in modo da poter analizzare i numeri di sequenza. Ora l'aggressore può inserire dati nel flusso di pacchetti senza essersi autenticato quando la connessione è stata stabilita per la prima volta.</p>\n<h3>Mezzi di comunicazione</h3>\n<p>i principali mezzi di comunicazioni sono :</p>\n<ul>\n<li><strong>cavo</strong>, sul quale viaggiano segnali elettrici,\n<ul>\n<li>posso aver più host sullo stesso cavo → riconfiguro mia scheda di rete in promisque mode, così facendo prende tutto il traffico che passa su quello spezzone di rete (intercettazione sullo stesso spezzone di rete)</li>\n<li>intercettazione dei segnali (radiazioni elettromagnetiche), questo attacco non è possibile da rivelare ex tramite programmini su router il quale intercetterà tutti i pacchetti</li>\n</ul>\n</li>\n<li><strong>Fibre ottiche</strong>, non emettono radiazioni, viaggiano sul principio di segnale lunminoso  difficile da inttercettare, può essere fatta solo sugli apparati di deflezione dei segnali</li>\n<li><strong>Microwave</strong> (wi-fi) tipologia di attacchi che non può essere rilevata ma prevenuta, basta avere un'antenna per poter prendere tutto quello che c'è nell'etere , i segnali dei satelliti sono più facili da intercettare , su microwave devo stare circa 10 mt mentre mer satelliti arco di 30km, la difficoltà sta nel conoscere lo schema di codifica dei multi canali dei satelliti</li>\n</ul>\n<p>essenzialmente il canale di comunicazione è un tallone d'achille per quanto riguarda la sicurezza sulla rete</p>\n<p>più facile di tutti il wifi, tipi di attacchi : <strong>intercettazione</strong> chiamata <strong>Eavesdropping</strong> o <strong>sniffing</strong> , attacco mirato a recuperare il contenuto che viaggia su quel canale di comunicazione indipendentemente dal canale</p>\n<p>si può fare intercettazione sfruttando</p>\n<ul>\n<li><strong>man in the middle</strong></li>\n<li><strong>compromettere un server ex tramite sniffer</strong></li>\n<li><strong>compromettere router</strong></li>\n</ul>"
                }
            ]
        },
        {
            "title": "Lezione Nuova",
            "sections": [
                {
                    "subtitle": "Introduzione",
                    "content": "<p>tabella attacchi</p>\n<p><a href=\"https://attack.mitre.org/#\">ATT&amp;CK Matrix for Enterprise</a></p>\n<p>si usano diversi metodi per fare riconoscimenti</p>\n<ul>\n<li>scanning, scansionamento in funzione del contesto:\n<ul>\n<li><strong>War Dialing,</strong> genera dei numeri telefonici a caso all'interno dell'azienda per vedere se quel numero risponde a un modem esterno all'azienda.</li>\n<li><strong>War Driving</strong>, intercettazione di reti wi-fi aperte, tramite antenna</li>\n<li><strong>Post scanning,</strong> scansiona le porte di un pc, il sio obbiettivo è quello di scoprire le porte aperte, se sappiamo che c'è un servizio aperto, possiamo andare a vedere se quel servizio ha dei bachi noti, essenzialmente si prova a forzarlo</li>\n</ul>\n</li>\n</ul>\n<h3>Nmap</h3>\n<p>prodotto open source ... aggiungo</p>\n<p>problema quando faccio post scann dato che faccio scan su tuttle le porte( &gt; 65000) posso essere scoperto, mando pacchetto dalla mia macchina pacchetto con indirizzo ip facile da risalire, faccio spoffing → problema la risposta non va a me ma al server.</p>\n<p>il post scanning non è un attacco, ma serve per prepararsi ad un attacco</p>\n<h4>Nmap output</h4>\n<p><em>provo</em></p>\n<p>database delle vulnrebilità → <strong>C.V.E</strong> vengono raccolte tutte le vulnerabilità di tutti i prodotti</p>"
                },
                {
                    "subtitle": "The Man in the Middle (MITM)",
                    "content": "<h3>Premessa</h3>\n<p>basato su rete, diversi da attacchi a livello host, sfruttano delle debolezze intrinseche a livello di rete ( a differnza di quelle precedenti che sono errori di programmazioni), debolezze dovutea errori di progettazioni.<br>\nInternet nasce come rete accademica e militare, l'obbiettivo è agevolare comunicazioni tra entità, in un contesto dove le persone si conoscono.<br>\nIl pressupposto di internet è che tutti gli utenti sono trusted, ex in IP inizialmete nessuno si era posto il problema di passare in chiaro le informazioni, questo arriva in un secondo tempo.</p>\n<h3>Introduzione</h3>\n<p>si piazza in mezzo tra un sender e un reciver, è in grado di prendere informazioni ma anche interferire, cambiando il contenuto.</p>\n<p>esistono diversi tipi a secondo dei livelli:</p>\n<ul>\n<li>Wifi Eavesdropping</li>\n<li>DNS spoofing</li>\n<li>Arp chache Poisoning</li>\n<li>Man in the Browser</li>\n<li>SSL, secure Socket layer Hijacjing</li>\n<li>Email hijacking</li>\n</ul>\n<h4>ARP chache</h4>\n<p>sfrutta criticità del protocollo ARP t<br>\nil contesto di riferimento è una LAN</p>\n<p>host 1 vuole comunicare con host2 , per farlo deve conoscere MAC addres, conosce IP address, quindi manda ARP reqeust per chiedere l'indirizzo fisico associato a quell'IP , l'host che è identificato con quell'IP risponderà con un ARP replay dove all'interno c'è il contenuto del suo mac address.<br>\nARP allora a questo punto salverà in chace il mapping tra indirizzo logico e fisico.</p>\n<p>ARP si basa sul fatto che gli host &quot; non mentono &quot;, si fida delle risposte</p>\n<p>l'attacco <strong>MITM</strong> sfrutta qusta debolezza mandandanto info sbagliate convinchendo l'host a cambiare la sua ARP cache facendo cambiare il mapping (logico - fisico) attraverso ARP replay questo attacco viene chiamato  <strong>ARP poisoning</strong></p>\n<h3>ARP poisoning</h3>\n<p>sistemo def sopra</p>\n<p>le entry della chache hanno un periodo di validaste, un paio di minuti, quidni bisogna mandare continuamente ARP requrire (circa ogni 30s).</p>\n<p>questo è un'attacco che intercetta info da A → B ma per essere un MITM deve fare anche B → A</p>\n<p>usiamo ETTERCAP</p>\n<p>x fare attacco dobbiamo inficaiare la chache di 2 host, mac addres dell'attaccande deve essere messo sia in A che in B</p>\n<p>in questa configuarazione può analizzare un pacchetto modificarlo e decidere se inviarlo all'altro host</p>\n<p>posso farlo solo all'interno di una LAN, ho bisogno del protoccollo ARP</p>\n<p>Effetti (quello che posso fare):</p>\n<ul>\n<li>Sniffing</li>\n<li>Dos</li>\n<li>TCP/IP sessione hijacking</li>\n</ul>\n<p>Sono stati fatti nel corso degli anni meccanismi per bloccare questo attacco ma è molto difficile dovrei modificare ARP che è contenuto in IP quindi dovrei modificare il protocollo IP.</p>\n<p>questo attacco funziona sulle ARP dinamiche non su quelle statiche</p>\n<h4>Dos - DDos</h4>\n<p>Denial of service, evitare a un utente l'uso leggittimo di un servizio , non mettere in condizione l'utente di utillizzare una risorsa o servizio.</p>\n<p>per farlo si può consumare</p>\n<ul>\n<li>connettività di rete</li>\n<li>risorse</li>\n<li>distruggere la macchina</li>\n</ul>\n<p>tipicamente rendere inaccessibile uno o più server</p>\n<p><em>foto 1</em></p>\n<h5>Smurf Attack</h5>\n<p>attacco di tipo Dos<br>\nmando un ICMP request a tutti gli utenti (Ping), quando server riceve il ping risponde con ICMP replay, l'idea è che mando fuori ping con indirizzo spooffato con IP della macchina che voglio attaccare</p>\n<h5>Syn Flood</h5>\n<p>sfrutta il protocollo TCP</p>\n<p>mando SYN ricevo ACK e al posto di rispomdere con SYN ack rispondo con SYN finchè la tabella delle connessioni del server non si riempie</p>\n<p>ora poco efficacie, ci vogliono più attacchi contemporaneamente → <strong>distributed Dos</strong></p>\n<p>macchina attaccante compromette primo livello che comporomette secondo livello e così via</p>\n<p>attaccande manda comando e le Boot map mandano attacco al server</p>\n<h5>TCP hijacking</h5>\n<p>attacco parte dal treway handshake</p>\n<p>sfrutta quindi TCP, per intromettersi deve conscre x,y</p>\n<p><em>foto2</em></p>\n<p>per sostituirmi al client devo mettere y + 1</p>\n<p>devo &quot;indovinare&quot; sequence number → faccio sniffing sui alcuni pacchetti e provo ad individuarli</p>"
                }
            ]
        }
    ]
}